This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-11T00:21:41.680Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  services/
    ethersService.ts
  tests/
    test.ts
  index.ts
  server.ts
.env.example
.gitignore
claude-server.json
package.json
tsconfig.json

================================================================
Files
================================================================

================
File: src/services/ethersService.ts
================
import { ethers } from "ethers";
import { z } from "zod";

export type DefaultProvider = 
    | "mainnet"      // Ethereum Mainnet
    | "sepolia"      // Sepolia Testnet
    | "goerli"       // Goerli Testnet
    | "arbitrum"     // Arbitrum
    | "optimism"     // Optimism
    | "base"         // Base
    | "polygon";     // Polygon

const DEFAULT_PROVIDERS = [
    "mainnet",
    "sepolia",
    "goerli",
    "arbitrum",
    "optimism",
    "base",
    "polygon"
];

// Move addressSchema to class level to avoid duplication
const addressSchema = z.string().regex(/^0x[a-fA-F0-9]{40}$/);

export class EthersService {
    private defaultProvider: ethers.Provider;

    constructor(defaultNetwork: DefaultProvider = "mainnet") {
        this.defaultProvider = this.createInfuraProvider(defaultNetwork);
    }

    private getInfuraApiKey(): string {
        const infuraApiKey = process.env.INFURA_API_KEY;
        if (!infuraApiKey) {
            throw new Error("Missing INFURA_API_KEY in environment variables.");
        }
        return infuraApiKey;
    }

    private createInfuraProvider(network: DefaultProvider): ethers.Provider {
        try {
            return new ethers.InfuraProvider(network as ethers.Networkish, this.getInfuraApiKey());
        } catch (error) {
            this.handleProviderError(error, `create Infura provider for network ${network}`);
        }
    }

    private validateRpcUrl(url: string): void {
        if (!url.match(/^https?:\/\/.+$/)) {
            throw new Error(`Invalid RPC URL format: ${url}. URL must start with http:// or https:// and include a valid domain.`);
        }
    }

    private handleProviderError(error: unknown, context: string, details?: Record<string, string>): never {
        if (error instanceof z.ZodError) {
            const firstError = error.errors[0];
            const message = firstError?.message || 'Invalid input format';
            throw new Error(`Invalid input format: ${message}. Expected a valid Ethereum address (0x followed by 40 hexadecimal characters)`);
        }

        // Handle provider errors
        if (error instanceof Error && 'code' in error) {
            throw new Error(`Failed to ${context}: Provider error: ${error.message}`);
        }

        // Generic error with context
        const err = error as { message?: string };
        const errorMessage = err.message || String(error);
        const detailsStr = details ? ` Details: ${Object.entries(details).map(([k, v]) => `${k}=${v}`).join(', ')}` : '';
        throw new Error(`Failed to ${context}: ${errorMessage}${detailsStr}`);
    }

    private getProvider(provider?: string): ethers.Provider {
        if (!provider) {
            return this.defaultProvider;
        }

        // Check if it's a default provider
        if (DEFAULT_PROVIDERS.includes(provider as DefaultProvider)) {
            try {
                return this.createInfuraProvider(provider as DefaultProvider);
            } catch (error) {
                this.handleProviderError(error, `create Infura provider for network ${provider}`);
            }
        }

        // Otherwise treat it as an RPC URL
        if (provider.startsWith("http")) {
            try {
                this.validateRpcUrl(provider);
                return new ethers.JsonRpcProvider(provider);
            } catch (error) {
                this.handleProviderError(error, `create provider with RPC URL ${provider}`);
            }
        }

        throw new Error(
            `Invalid provider: ${provider}. Must be either:\n` +
            `1. A supported network name (${DEFAULT_PROVIDERS.join(", ")})\n` +
            `2. A valid RPC URL starting with http:// or https://`
        );
    }

    async getBalance(address: string, provider?: string): Promise<string> {
        try {
            addressSchema.parse(address);
            const selectedProvider = this.getProvider(provider);
            const balance = await selectedProvider.getBalance(address);
            return ethers.formatEther(balance);
        } catch (error) {
            this.handleProviderError(error, "fetch balance", { address });
        }
    }

    async getERC20Balance(address: string, tokenAddress: string, provider?: string): Promise<string> {
        try {
            addressSchema.parse(address);
            addressSchema.parse(tokenAddress);
            const selectedProvider = this.getProvider(provider);
            const contract = new ethers.Contract(
                tokenAddress,
                [
                    "function balanceOf(address) view returns (uint)",
                    "function decimals() view returns (uint8)"
                ],
                selectedProvider
            );

            const decimals = await contract.decimals();
            const balance = await contract.balanceOf(address);
            return ethers.formatUnits(balance, decimals);
        } catch (error) {
            this.handleProviderError(error, "fetch ERC20 balance", { address, tokenAddress });
        }
    }

    async getTransactionCount(address: string, provider?: string): Promise<number> {
        try {
            addressSchema.parse(address);
            const selectedProvider = this.getProvider(provider);
            const count = await selectedProvider.getTransactionCount(address);
            return count;
        } catch (error) {
            this.handleProviderError(error, "fetch transaction count", { address });
        }
    }

    async getBlockNumber(provider?: string): Promise<number> {
        try {
            const selectedProvider = this.getProvider(provider);
            return await selectedProvider.getBlockNumber();
        } catch (error) {
            this.handleProviderError(error, "fetch latest block number");
        }
    }

    async getBlockDetails(blockTag: string | number, provider?: string): Promise<ethers.Block | null> {
        try {
            const selectedProvider = this.getProvider(provider);
            const block = await selectedProvider.getBlock(blockTag);
            return block;
        } catch (error) {
            this.handleProviderError(error, "fetch block details", { blockTag: String(blockTag) });
        }
    }

    async getTransactionDetails(txHash: string, provider?: string): Promise<ethers.TransactionResponse | null> {
        try {
            const txSchema = z.string().regex(/^0x[a-fA-F0-9]{64}$/);
            txSchema.parse(txHash);
            const selectedProvider = this.getProvider(provider);
            return await selectedProvider.getTransaction(txHash);
        } catch (error) {
            this.handleProviderError(error, "fetch transaction details", { txHash });
        }
    }

    async getGasPrice(provider?: string): Promise<string> {
        try {
            const selectedProvider = this.getProvider(provider);
            const feeData = await selectedProvider.getFeeData();
            return ethers.formatUnits(feeData.gasPrice || 0n, "gwei");
        } catch (error) {
            this.handleProviderError(error, "get gas price");
        }
    }

    async getFeeData(provider?: string): Promise<ethers.FeeData> {
        try {
            const selectedProvider = this.getProvider(provider);
            return await selectedProvider.getFeeData();
        } catch (error) {
            this.handleProviderError(error, "get fee data");
        }
    }

    async getContractCode(address: string, provider?: string): Promise<string | null> {
        try {
            addressSchema.parse(address);
            const selectedProvider = this.getProvider(provider);
            return await selectedProvider.getCode(address);
        } catch (error) {
            this.handleProviderError(error, "get contract bytecode", { address });
        }
    }

    async lookupAddress(address: string, provider?: string): Promise<string | null> {
        try {
            addressSchema.parse(address);
            const selectedProvider = this.getProvider(provider);
            return await selectedProvider.lookupAddress(address);
        } catch (error) {
            this.handleProviderError(error, "look up ENS name for address", { address });
        }
    }

    async resolveName(name: string, provider?: string): Promise<string | null> {
        try {
            const selectedProvider = this.getProvider(provider);
            return await selectedProvider.resolveName(name);
        } catch (error) {
            this.handleProviderError(error, "resolve ENS name", { name });
        }
    }

    formatEther(wei: string | number | bigint): string {
        try {
            return ethers.formatEther(wei);
        } catch (error) {
            this.handleProviderError(error, "format Ether value", { wei: String(wei) });
        }
    }

    parseEther(ether: string): bigint {
        try {
            return ethers.parseEther(ether);
        } catch (error) {
            this.handleProviderError(error, "parse Ether string", { ether });
        }
    }

    formatUnits(value: string | number | bigint, unit: string | number): string {
        try {
            return ethers.formatUnits(value, unit);
        } catch (error) {
            this.handleProviderError(error, "format units", { value: String(value), unit: String(unit) });
        }
    }

    parseUnits(value: string, unit: string | number): bigint {
        try {
            return ethers.parseUnits(value, unit);
        } catch (error) {
            this.handleProviderError(error, "parse units", { value, unit: String(unit) });
        }
    }

    private getSigner(provider?: string): ethers.Signer {
        const privateKey = process.env.PRIVATE_KEY;
        if (!privateKey) {
            throw new Error("Missing PRIVATE_KEY in environment variables.");
        }
        const selectedProvider = this.getProvider(provider);
        return new ethers.Wallet(privateKey, selectedProvider);
    }

    async createTransaction(to: string, value: string, data?: string, provider?: string): Promise<ethers.TransactionRequest> {
        try {
            addressSchema.parse(to);
            const parsedValue = ethers.parseEther(value);

            const transaction: ethers.TransactionRequest = {
                to,
                value: parsedValue,
                data: data || "0x",
            };
            
            const signer = this.getSigner(provider);
            const populatedTx = await signer.populateTransaction(transaction);
            return populatedTx;
        } catch (error) {
            this.handleProviderError(error, "create transaction", { to, value });
        }
    }

    async estimateGas(tx: ethers.TransactionRequest, provider?: string): Promise<bigint> {
        try {
            const signer = this.getSigner(provider);
            const result = await signer.estimateGas(tx);
            return result;
        } catch (error) {
            this.handleProviderError(error, "estimate gas", { tx: JSON.stringify(tx) });
        }
    }

    async sendTransaction(to: string, value: string, data?: string, provider?: string): Promise<ethers.TransactionResponse> {
        try {
            const transaction = await this.createTransaction(to, value, data, provider);
            const signer = this.getSigner(provider);
            return await signer.sendTransaction(transaction);
        } catch (error) {
            this.handleProviderError(error, "send transaction", { to, value, data: data || "0x" });
        }
    }

    async signMessage(message: string, provider?: string): Promise<string> {
        try {
            const signer = this.getSigner(provider);
            return await signer.signMessage(message);
        } catch (error) {
            this.handleProviderError(error, "sign message", { message });
        }
    }

    async contractCall(
        contractAddress: string,
        abi: string,
        method: string,
        args: any[] = [],
        value: string = "0",
        provider?: string
    ): Promise<any> {
        try {
            addressSchema.parse(contractAddress);
            const signer = this.getSigner(provider);
            const contract = new ethers.Contract(
                contractAddress,
                abi,
                signer
            );
            const parsedValue = ethers.parseEther(value);
            const tx = await contract[method](...args, { value: parsedValue });
            return tx;
        } catch (error) {
            this.handleProviderError(error, `call contract method: ${method}`, {
                contractAddress,
                abi: JSON.stringify(abi),
                args: JSON.stringify(args),
                value
            });
        }
    }
}

================
File: src/tests/test.ts
================
import { EthersService } from '../services/ethersService.js';
import { config } from 'dotenv';

config();

async function testGetBalance() {
    const ethersService = new EthersService();
    
    // Test cases
    const testCases = [
        // Vitalik's address
        {
            address: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045',
            shouldSucceed: true
        },
        // Invalid address
        {
            address: 'invalid-address',
            shouldSucceed: false
        },
        // Wrong format address
        {
            address: '0x123',
            shouldSucceed: false
        }
    ];

    for (const test of testCases) {
        try {
            const balance = await ethersService.getBalance(test.address);
            console.log(`✅ Balance for ${test.address}: ${balance} ETH`);
            if (!test.shouldSucceed) {
                console.error('❌ Test failed: Expected error but got success');
            }
        } catch (error: unknown) {
            if (error instanceof Error) {
                console.error(`❌ Error for ${test.address}: ${error.message}`);
                if (test.shouldSucceed) {
                    console.error('❌ Test failed: Expected success but got error');
                }
            } else {
                console.error(`❌ Error for ${test.address}: Unknown error type`);
            }
        }
    }
}

testGetBalance().catch((error: unknown) => {
    if (error instanceof Error) {
        console.error('Test execution failed:', error.message);
    } else {
        console.error('Test execution failed with unknown error type');
    }
});

================
File: src/index.ts
================
#!/usr/bin/env node
import { startServer } from './server.js';
import { config } from 'dotenv';

config();

startServer().catch((error) => {
    console.error('Failed to start server:', error);
    process.exit(1);
});

================
File: src/server.ts
================
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
    CallToolRequestSchema,
    ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { EthersService, DefaultProvider } from "./services/ethersService.js";
import { z } from "zod";
import { config } from "dotenv";

config(); // Load environment variables

const server = new Server(
    {
        name: "ethers-wallet-server",
        version: "1.0.0",
    },
    {
        capabilities: {
            tools: {},
        },
    }
);

// Initialize the ethers service with configurable default network
const defaultNetwork = (process.env.DEFAULT_NETWORK || "mainnet") as DefaultProvider;
const ethersService = new EthersService(defaultNetwork);

// Tool definitions
const tools = [
    {
        name: "getWalletBalance",
        description: "Get the ETH balance of a wallet",
        inputSchema: {
            type: "object",
            properties: {
                address: {
                    type: "string",
                    description: "The Ethereum address to query",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL. Defaults to mainnet if not provided.",
                },
            },
            required: ["address"],
        },
    },
    {
        name: "getERC20Balance",
        description: "Get the ERC20 token balance of a wallet",
        inputSchema: {
            type: "object",
            properties: {
                address: {
                    type: "string",
                    description: "The Ethereum address to query",
                },
                tokenAddress: {
                    type: "string",
                    description: "The address of the ERC20 token contract"
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL. Defaults to mainnet if not provided.",
                },
            },
            required: ["address", "tokenAddress"]
        },
    },
    {
        name: "getWalletTransactionCount",
        description: "Get the number of transactions ever sent by an address",
        inputSchema: {
            type: "object",
            properties: {
                address: {
                    type: "string",
                    description: "The Ethereum address to query",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL. Defaults to mainnet if not provided.",
                },
            },
            required: ["address"]
        },
    },
    {
        name: "getBlockNumber",
        description: "Get the current block number",
        inputSchema: {
            type: "object",
            properties: {
                provider: {
                    type: "string",
                    description: "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL. Defaults to mainnet if not provided.",
                },
            },
        },
    },
    {
        name: "getBlockDetails",
        description: "Get details about a block",
        inputSchema: {
            type: "object",
            properties: {
                blockTag: {
                    type: ["string", "number"],
                    description: "The block number or the string 'latest'",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL. Defaults to mainnet if not provided.",
                },
            },
            required: ["blockTag"]
        },
    },
    {
        name: "getTransactionDetails",
        description: "Get details about a transaction",
        inputSchema: {
            type: "object",
            properties: {
                txHash: {
                    type: "string",
                    description: "The transaction hash to lookup",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL. Defaults to mainnet if not provided.",
                },
            },
            required: ["txHash"]
        },
    },
    {
        name: "getGasPrice",
        description: "Get the current gas price",
        inputSchema: {
            type: "object",
            properties: {
                provider: {
                    type: "string",
                    description: "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL. Defaults to mainnet if not provided.",
                },
            },
        },
    },
    {
        name: "getFeeData",
        description: "Get the current network fee data",
        inputSchema: {
            type: "object",
            properties: {
                provider: {
                    type: "string",
                    description: "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL. Defaults to mainnet if not provided.",
                },
            },
        },
    },
    {
        name: "getContractCode",
        description: "Get a contract's bytecode",
        inputSchema: {
            type: "object",
            properties: {
                address: {
                    type: "string",
                    description: "The contract's address",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL. Defaults to mainnet if not provided.",
                },
            },
            required: ["address"]
        },
    },
    {
        name: "lookupAddress",
        description: "Get the ENS name for an address",
        inputSchema: {
            type: "object",
            properties: {
                address: {
                    type: "string",
                    description: "The Ethereum address to resolve",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL. Defaults to mainnet if not provided.",
                },
            },
            required: ["address"]
        },
    },
    {
        name: "resolveName",
        description: "Get the address for an ENS name",
        inputSchema: {
            type: "object",
            properties: {
                name: {
                    type: "string",
                    description: "The ENS name to resolve",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL. Defaults to mainnet if not provided.",
                },
            },
            required: ["name"]
        },
    },
    {
        name: "formatEther",
        description: "Convert a wei value to a decimal string in ether",
        inputSchema: {
            type: "object",
            properties: {
                wei: {
                    type: "string",
                    description: "The wei value to format",
                },
            },
            required: ["wei"]
        },
    },
    {
        name: "parseEther",
        description: "Convert an ether value to wei",
        inputSchema: {
            type: "object",
            properties: {
                ether: {
                    type: "string",
                    description: "The ether value to parse",
                },
            },
            required: ["ether"]
        },
    },
    {
        name: "formatUnits",
        description: "Convert a value to a decimal string with specified units",
        inputSchema: {
            type: "object",
            properties: {
                value: {
                    type: "string",
                    description: "The value to format",
                },
                unit: {
                    type: ["string", "number"],
                    description: "The number of decimals or unit name (e.g., 'gwei', 18)",
                },
            },
            required: ["value", "unit"]
        },
    },
    {
        name: "parseUnits",
        description: "Convert a decimal string to its smallest unit representation",
        inputSchema: {
            type: "object",
            properties: {
                value: {
                    type: "string",
                    description: "The decimal string to parse",
                },
                unit: {
                    type: ["string", "number"],
                    description: "The number of decimals or unit name (e.g., 'gwei', 18)",
                },
            },
            required: ["value", "unit"]
        },
    },
    {
        name: "sendTransaction",
        description: "Send ETH from the server's wallet to a recipient",
        inputSchema: {
            type: "object",
            properties: {
                to: {
                    type: "string",
                    description: "The recipient address",
                },
                value: {
                    type: "string",
                    description: "The amount of ETH to send",
                },
                data: {
                    type: "string",
                    description: "Optional. Data to include in the transaction",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL. Defaults to mainnet if not provided.",
                },
            },
            required: ["to", "value"]
        },
    },
    {
        name: "signMessage",
        description: "Sign a message using the server's wallet",
        inputSchema: {
            type: "object",
            properties: {
                message: {
                    type: "string",
                    description: "The message to sign",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL. Defaults to mainnet if not provided.",
                },
            },
            required: ["message"]
        },
    },
    {
        name: "contractCall",
        description: "Call a method on a smart contract",
        inputSchema: {
            type: "object",
            properties: {
                contractAddress: {
                    type: "string",
                    description: "The address of the smart contract",
                },
                abi: {
                    type: "string",
                    description: "The ABI of the contract as a JSON string",
                },
                method: {
                    type: "string",
                    description: "The method name to invoke",
                },
                methodArgs: {
                    type: "array",
                    description: "An array of arguments to pass to the method",
                    items: {
                        type: ["string", "number", "boolean", "object"]
                    }
                },
                value: {
                    type: "string",
                    description: "Optional. The amount of ETH to send with the call",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL. Defaults to mainnet if not provided.",
                },
            },
            required: ["contractAddress", "abi", "method"]
        },
    },
];

// Define available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
    return { tools };
});

// Tool handlers
const toolHandlers = {
    getWalletBalance: async (args: unknown) => {
        const schema = z.object({ 
            address: z.string(),
            provider: z.string().optional()
        });
        const { address, provider } = schema.parse(args);
        const balance = await ethersService.getBalance(address, provider);
        
        return {
            content: [
                {
                    type: "text",
                    text: `The balance of ${address} is ${balance} ETH`,
                },
            ],
        };
    },
    
    getERC20Balance: async (args: unknown) => {
        const schema = z.object({ 
            address: z.string(), 
            tokenAddress: z.string(),
            provider: z.string().optional()
        });
        const { address, tokenAddress, provider } = schema.parse(args);
        const balance = await ethersService.getERC20Balance(address, tokenAddress, provider);
        return {
            content: [
                {
                    type: "text",
                    text: `The balance of ${address} is ${balance} in ${tokenAddress}`
                },
            ],
        };
    },
    
    getWalletTransactionCount: async (args: unknown) => {
        const schema = z.object({ 
            address: z.string(),
            provider: z.string().optional()
        });
        const { address, provider } = schema.parse(args);
        const count = await ethersService.getTransactionCount(address, provider);
        return {
            content: [{ type: "text", text: `The transaction count for ${address} is ${count}` }],
        };
    },

    getBlockNumber: async (args: unknown) => {
        const schema = z.object({ provider: z.string().optional() });
        const { provider } = schema.parse(args);
        const blockNumber = await ethersService.getBlockNumber(provider);
        return {
            content: [{ type: "text", text: `The current block number is ${blockNumber}` }],
        };
    },

    getBlockDetails: async (args: unknown) => {
        const schema = z.object({
            blockTag: z.union([z.string(), z.number()]),
            provider: z.string().optional()
        });
        const { blockTag, provider } = schema.parse(args);
        const blockDetails = await ethersService.getBlockDetails(blockTag, provider);
        
        if (blockDetails === null) {
            return {
                isError: true,
                content: [{ type: "text", text: `Block not found for tag: ${blockTag}` }]
            };
        }

        return {
            content: [{ type: "text", text: JSON.stringify(blockDetails, null, 2) }],
        };
    },

    getTransactionDetails: async (args: unknown) => {
        const schema = z.object({
            txHash: z.string(),
            provider: z.string().optional()
        });
        const { txHash, provider } = schema.parse(args);
        const txDetails = await ethersService.getTransactionDetails(txHash, provider);
        
        if (txDetails === null) {
            return {
                isError: true,
                content: [{ type: "text", text: `Transaction not found: ${txHash}` }]
            };
        }

        return {
            content: [{ type: "text", text: JSON.stringify(txDetails, null, 2) }],
        };
    },

    getGasPrice: async (args: unknown) => {
        const schema = z.object({ provider: z.string().optional() });
        const { provider } = schema.parse(args);
        const gasPrice = await ethersService.getGasPrice(provider);
        return {
            content: [{ type: "text", text: `The current gas price is ${gasPrice} gwei` }],
        };
    },

    getFeeData: async (args: unknown) => {
        const schema = z.object({ provider: z.string().optional() });
        const { provider } = schema.parse(args);
        const feeData = await ethersService.getFeeData(provider);
        return {
            content: [{ type: "text", text: JSON.stringify(feeData, null, 2) }],
        };
    },

    getContractCode: async (args: unknown) => {
        const schema = z.object({
            address: z.string(),
            provider: z.string().optional()
        });
        const { address, provider } = schema.parse(args);
        const code = await ethersService.getContractCode(address, provider);
        
        if (code === null || code === "0x") {
            return {
                isError: true,
                content: [{ type: "text", text: `No code found at address: ${address}` }]
            };
        }

        return {
            content: [{ type: "text", text: `Contract bytecode at ${address}:\n\n${code}` }],
        };
    },

    lookupAddress: async (args: unknown) => {
        const schema = z.object({
            address: z.string(),
            provider: z.string().optional()
        });
        const { address, provider } = schema.parse(args);
        const ensName = await ethersService.lookupAddress(address, provider);
        
        if (ensName === null) {
            return {
                content: [{ type: "text", text: `No ENS name found for address: ${address}` }]
            };
        }

        return {
            content: [{ type: "text", text: `The ENS name for ${address} is ${ensName}` }],
        };
    },

    resolveName: async (args: unknown) => {
        const schema = z.object({
            name: z.string(),
            provider: z.string().optional()
        });
        const { name, provider } = schema.parse(args);
        const address = await ethersService.resolveName(name, provider);
        
        if (address === null) {
            return {
                content: [{ type: "text", text: `No address found for ENS name: ${name}` }]
            };
        }

        return {
            content: [{ type: "text", text: `The address for ${name} is ${address}` }],
        };
    },

    formatEther: async (args: unknown) => {
        const schema = z.object({
            wei: z.string()
        });
        const { wei } = schema.parse(args);
        const formatted = ethersService.formatEther(wei);
        return {
            content: [{ type: "text", text: `${wei} wei = ${formatted} ETH` }],
        };
    },

    parseEther: async (args: unknown) => {
        const schema = z.object({
            ether: z.string()
        });
        const { ether } = schema.parse(args);
        const parsed = ethersService.parseEther(ether);
        return {
            content: [{ type: "text", text: `${ether} ETH = ${parsed} wei` }],
        };
    },

    formatUnits: async (args: unknown) => {
        const schema = z.object({
            value: z.string(),
            unit: z.union([z.string(), z.number()])
        });
        const { value, unit } = schema.parse(args);
        const formatted = ethersService.formatUnits(value, unit);
        return {
            content: [{ type: "text", text: `${value} = ${formatted} (with ${unit} decimals)` }],
        };
    },

    parseUnits: async (args: unknown) => {
        const schema = z.object({
            value: z.string(),
            unit: z.union([z.string(), z.number()])
        });
        const { value, unit } = schema.parse(args);
        const parsed = ethersService.parseUnits(value, unit);
        return {
            content: [{ type: "text", text: `${value} = ${parsed} (with ${unit} decimals)` }],
        };
    },

    sendTransaction: async (args: unknown) => {
        const schema = z.object({
            to: z.string(),
            value: z.string(),
            data: z.string().optional(),
            provider: z.string().optional()
        });
        const { to, value, data, provider } = schema.parse(args);
        try {
            const tx = await ethersService.sendTransaction(to, value, data, provider);
            return {
                content: [{
                    type: "text",
                    text: `Transaction sent with hash ${tx.hash}`
                }]
            };
        } catch (error) {
            return {
                isError: true,
                content: [{ type: "text", text: `Transaction failed: ${error instanceof Error ? error.message : String(error)}` }]
            };
        }
    },

    signMessage: async (args: unknown) => {
        const schema = z.object({
            message: z.string(),
            provider: z.string().optional()
        });
        const { message, provider } = schema.parse(args);
        try {
            const signature = await ethersService.signMessage(message, provider);
            return {
                content: [{
                    type: "text",
                    text: `Signature: ${signature}`
                }]
            };
        } catch (error) {
            return {
                isError: true,
                content: [{ type: "text", text: `Message signing failed: ${error instanceof Error ? error.message : String(error)}` }]
            };
        }
    },

    contractCall: async (args: unknown) => {
        const schema = z.object({
            contractAddress: z.string(),
            abi: z.string(),
            method: z.string(),
            methodArgs: z.array(z.any()).optional(),
            value: z.string().optional(),
            provider: z.string().optional()
        });
        const { contractAddress, abi, method, methodArgs = [], value = "0", provider } = schema.parse(args);
        try {
            const result = await ethersService.contractCall(contractAddress, abi, method, methodArgs, value, provider);
            return {
                content: [{
                    type: "text",
                    text: JSON.stringify(result, null, 2)
                }]
            };
        } catch (error) {
            return {
                isError: true,
                content: [{ type: "text", text: `Contract call failed: ${error instanceof Error ? error.message : String(error)}` }]
            };
        }
    },
};

// Handle tool calls
server.setRequestHandler(CallToolRequestSchema, async (request) => {
    const { name, arguments: args } = request.params;

    try {
        const handler = toolHandlers[name as keyof typeof toolHandlers];
        if (!handler) {
            throw new Error(`Tool not found: ${name}`);
        }
        return await handler(args);
    } catch (error: any) {
        return {
            isError: true,
            content: [{ type: "text", text: `Error processing the request: ${error.message}` }]
        };
    }
});

export async function startServer() {
    const transport = new StdioServerTransport();
    await server.connect(transport);
    console.error(`MCP server running on stdio (default network: ${defaultNetwork})`);
}

================
File: .env.example
================
INFURA_API_KEY=your_infura_api_key_here

================
File: .gitignore
================
node_modules/
build/
.env

================
File: claude-server.json
================
{
    "name": "ethers-wallet-server",
    "description": "A server that provides Ethereum wallet and blockchain interaction capabilities",
    "command": "node build/index.js",
    "tools": [
        {
            "name": "getWalletBalance",
            "description": "Get the ETH balance of a wallet",
            "parameters": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The Ethereum address to query"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["address"]
            }
        },
        {
            "name": "getERC20Balance",
            "description": "Get the ERC20 token balance of a wallet",
            "parameters": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The Ethereum address to query"
                    },
                    "tokenAddress": {
                        "type": "string",
                        "description": "The address of the ERC20 token contract"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["address", "tokenAddress"]
            }
        },
        {
            "name": "getWalletTransactionCount",
            "description": "Get the number of transactions ever sent by an address",
            "parameters": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The Ethereum address to query"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["address"]
            }
        },
        {
            "name": "getBlockNumber",
            "description": "Get the current block number",
            "parameters": {
                "type": "object",
                "properties": {
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                }
            }
        },
        {
            "name": "getBlockDetails",
            "description": "Get details about a block",
            "parameters": {
                "type": "object",
                "properties": {
                    "blockTag": {
                        "type": ["string", "number"],
                        "description": "The block number or the string 'latest'"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["blockTag"]
            }
        },
        {
            "name": "getTransactionDetails",
            "description": "Get details about a transaction",
            "parameters": {
                "type": "object",
                "properties": {
                    "txHash": {
                        "type": "string",
                        "description": "The transaction hash to lookup"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["txHash"]
            }
        },
        {
            "name": "getGasPrice",
            "description": "Get the current gas price",
            "parameters": {
                "type": "object",
                "properties": {
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                }
            }
        },
        {
            "name": "getFeeData",
            "description": "Get the current network fee data",
            "parameters": {
                "type": "object",
                "properties": {
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                }
            }
        },
        {
            "name": "getContractCode",
            "description": "Get a contract's bytecode",
            "parameters": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The contract's address"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["address"]
            }
        },
        {
            "name": "lookupAddress",
            "description": "Get the ENS name for an address",
            "parameters": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The Ethereum address to resolve"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["address"]
            }
        },
        {
            "name": "resolveName",
            "description": "Get the address for an ENS name",
            "parameters": {
                "type": "object",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The ENS name to resolve"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["name"]
            }
        },
        {
            "name": "formatEther",
            "description": "Convert a wei value to a decimal string in ether",
            "parameters": {
                "type": "object",
                "properties": {
                    "wei": {
                        "type": "string",
                        "description": "The wei value to format"
                    }
                },
                "required": ["wei"]
            }
        },
        {
            "name": "parseEther",
            "description": "Convert an ether value to wei",
            "parameters": {
                "type": "object",
                "properties": {
                    "ether": {
                        "type": "string",
                        "description": "The ether value to parse"
                    }
                },
                "required": ["ether"]
            }
        },
        {
            "name": "formatUnits",
            "description": "Convert a value to a decimal string with specified units",
            "parameters": {
                "type": "object",
                "properties": {
                    "value": {
                        "type": "string",
                        "description": "The value to format"
                    },
                    "unit": {
                        "type": ["string", "number"],
                        "description": "The number of decimals or unit name (e.g., 'gwei', 18)"
                    }
                },
                "required": ["value", "unit"]
            }
        },
        {
            "name": "parseUnits",
            "description": "Convert a decimal string to its smallest unit representation",
            "parameters": {
                "type": "object",
                "properties": {
                    "value": {
                        "type": "string",
                        "description": "The decimal string to parse"
                    },
                    "unit": {
                        "type": ["string", "number"],
                        "description": "The number of decimals or unit name (e.g., 'gwei', 18)"
                    }
                },
                "required": ["value", "unit"]
            }
        },
        {
            "name": "sendTransaction",
            "description": "Send ETH from the server's wallet to a recipient",
            "parameters": {
                "type": "object",
                "properties": {
                    "to": {
                        "type": "string",
                        "description": "The recipient address"
                    },
                    "value": {
                        "type": "string",
                        "description": "The amount of ETH to send"
                    },
                    "data": {
                        "type": "string",
                        "description": "Optional. Data to include in the transaction"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["to", "value"]
            }
        },
        {
            "name": "signMessage",
            "description": "Sign a message using the server's wallet",
            "parameters": {
                "type": "object",
                "properties": {
                    "message": {
                        "type": "string",
                        "description": "The message to sign"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["message"]
            }
        },
        {
            "name": "contractCall",
            "description": "Call a method on a smart contract",
            "parameters": {
                "type": "object",
                "properties": {
                    "contractAddress": {
                        "type": "string",
                        "description": "The address of the smart contract"
                    },
                    "abi": {
                        "type": "string",
                        "description": "The ABI of the contract as a JSON string"
                    },
                    "method": {
                        "type": "string",
                        "description": "The method name to invoke"
                    },
                    "methodArgs": {
                        "type": "array",
                        "description": "An array of arguments to pass to the method",
                        "items": {
                            "type": ["string", "number", "boolean", "object"]
                        }
                    },
                    "value": {
                        "type": "string",
                        "description": "Optional. The amount of ETH to send with the call"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["contractAddress", "abi", "method"]
            }
        }
    ]
}

================
File: package.json
================
{
  "name": "mcp-ethers-wallet",
  "version": "1.0.0",
  "type": "module",
  "main": "build/index.js",
  "types": "build/index.d.ts",
  "bin": {
    "mcp-ethers-wallet": "build/index.js"
  },
  "scripts": {
    "build": "tsc && node -e \"require('fs').chmodSync('build/index.js', '755')\"",
    "prepublishOnly": "npm run build",
    "start": "node build/index.js",
    "test": "tsc && node build/tests/test.js"
  },
  "files": [
    "build"
  ],
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "ethers": "^6.0.0",
    "dotenv": "^16.0.0",
    "zod": "^3.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  },
  "engines": {
    "node": ">=18"
  }
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "outDir": "./build",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
